# -*- coding: utf-8 -*-
"""
/***************************************************************************
 QStreamDockWidget
                                 A QGIS plugin
 QStream - Mesoscopic Traffic Simulation
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2019-01-07
        git sha              : $Format:%H$
        copyright            : (C) 2019 by Aurélien Clairais / CEREMA
        email                : aurelien.clairais@cerema.fr
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import sys
import os
import shutil
import numpy as np
from sys import executable
from pyexcel_ods import save_data, get_data
import json
from functools import partial
import subprocess

from qgis.utils import iface
from qgis.core import QgsProject, QgsWkbTypes, QgsFeature, QgsGeometry, QgsPointXY, QgsFeatureRequest, QgsExpression, QgsVectorLayer, QgsVectorFileWriter
from qgis.core.additions.edit import edit


from PyQt5 import QtGui, QtWidgets, uic, QtCore
from PyQt5.QtCore import pyqtSignal, QCoreApplication, QSize

#...
# other forms
from .forms.MLwidget import MLWidget
from .forms.Generalwidget import GeneralWidget
from .forms.RTwidget import RTWidget
from .forms.generateXTwidget import generateXTWidget
from .scenario import Scenario


""" UTILITIES ! """
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'Qstream_dockwidget_network2.ui'))

STREAM_MIN_VERSION = '3.1.0'

BASE_DIR = os.path.dirname(__file__)
def absolutePath(relativePath):
    return os.path.join(BASE_DIR, relativePath)

def convertSecondsTohhmmss(time):
    hours = int(time/3600)
    minutes = int((time%3600)/60)
    seconds = time%60
    string = str(int(hours/10)) + str(hours%10) + "." + str(int(minutes/10)) + str(minutes%10) + "." + str(int(seconds/10)) + str(seconds%10)
    return string

def convertHHMMSStoSeconds(stringTime):
    seconds = int(stringTime[0])*36000 + int(stringTime[1])*3600 + int(stringTime[3])*600 +  int(stringTime[4])*60 +  int(stringTime[6])*10 +  int(stringTime[7])
    return seconds

correspondance_noms_regul = {'managed_lane' : 'v_Reservée'}

""" Main Class """
class QStreamDockWidget(QtWidgets.QDockWidget, FORM_CLASS):

    closingPlugin = pyqtSignal()

    def __init__(self, parent=None):
        """Constructor."""
        super(QStreamDockWidget, self).__init__(parent)
        # Set up the user interface from Designer.
        # After setupUI you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://doc.qt.io/qt-5/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)

        ### FOLDER
        #self.currentFolder = 'test_folder'
        #self.currentFile = 'testDB'


        # # #setup graphic

        self.setStyleSheet("""

            #dockWidgetContents{
                background-color : rgb(211,95,95);
            }

            #scrollAreaNetwork{
                background-color: rgb(255,255,255);
                border-style : none;
            }

            QTabBar::tab{
                font-weight : bold;
                font-size : 8pt;
                min-height: 100px;
            }

            QTabBar::tab:selected{
                background-color: rgb(255,255,255);
                color : rgb(211,95,95);
                font-size : 10pt;
                }
            QTabBar::tab:!selected{
                background: transparent;
                color : rgb(255,255,255);
                }

            QTabBar::tab:hover{
                font-size : 10pt;
            }

            QTabWidget::pane{
                background-color : rgb(255,255,255);
                border-style : none;
            }

            QToolButton{
                background-color: rgb(255,255,255);
                border-style : none;
            }

            """)

        # # # setup icons for Tool buttons # # #
        ## Netowk
        ICON_SIZE = 36
        ### Configuration
        self.saveTB.setIcon(QtGui.QIcon(':/plugins/Qstream/icons/save.png'))
        #↕self.saveTB.setMinimumSize(QSize(ICON_SIZE, ICON_SIZE))
        self.saveTB.setIconSize(QSize(ICON_SIZE, ICON_SIZE))
        self.importTB.setIcon(QtGui.QIcon(':/plugins/Qstream/icons/load.png'))
        #self.importTB.setMinimumSize(QSize(ICON_SIZE, ICON_SIZE))
        self.importTB.setIconSize(QSize(ICON_SIZE, ICON_SIZE))
        self.newTB.setIcon(QtGui.QIcon(':/plugins/Qstream/icons/new.png'))
        #self.newTB.setMinimumSize(QSize(ICON_SIZE, ICON_SIZE))
        self.newTB.setIconSize(QSize(ICON_SIZE, ICON_SIZE))
        self.exportTB.setIcon(QtGui.QIcon(':/plugins/Qstream/icons/export.png'))
        self.exportTB.setIconSize(QSize(ICON_SIZE, ICON_SIZE))


        ### Road Type
        self.roadType_TB.setIcon(QtGui.QIcon(':/plugins/Qstream/icons/roadType.png'))
        #self.roadType_TB.setMinimumSize(QSize(192, ICON_SIZE))
        self.roadType_TB.setIconSize(QSize(ICON_SIZE, ICON_SIZE))

        ### Links Edition
        self.addLinkReverseTB.setIcon(QtGui.QIcon(':/plugins/Qstream/icons/addReverse2.png'))
        #self.deleteLinkTB.setMinimumSize(QSize(192, ICON_SIZE))
        self.addLinkReverseTB.setIconSize(QSize(ICON_SIZE, ICON_SIZE))
        self.addLinkTB.setIcon(QtGui.QIcon(':/plugins/Qstream/icons/addLink.png'))
        #self.addLinkTB.setMinimumSize(QSize(192, ICON_SIZE))
        self.addLinkTB.setIconSize(QSize(ICON_SIZE, ICON_SIZE))
        self.reverseLinkTB.setIcon(QtGui.QIcon(':/plugins/Qstream/icons/reverseLink2.png'))
        #self.reverseLinkTB.setMinimumSize(QSize(192, ICON_SIZE))
        self.reverseLinkTB.setIconSize(QSize(ICON_SIZE, ICON_SIZE))

        ### Nodes edition
        self.mergeNodeTB.setIcon(QtGui.QIcon(':/plugins/Qstream/icons/mergeNodes.png'))
        #self.mergeNodeTB.setMinimumSize(QSize(192, ICON_SIZE))
        self.mergeNodeTB.setIconSize(QSize(ICON_SIZE, ICON_SIZE))
        self.splitNodeTB.setIcon(QtGui.QIcon(':/plugins/Qstream/icons/splitNode.png'))
        #self.mergeNodeTB.setMinimumSize(QSize(192, ICON_SIZE))
        self.splitNodeTB.setIconSize(QSize(ICON_SIZE, ICON_SIZE))
        self.deleteNodesTB.setIcon(QtGui.QIcon(':/plugins/Qstream/icons/deleteNodes.png'))
        #self.splitNodeTB.setMinimumSize(QSize(192, ICON_SIZE))
        self.deleteNodesTB.setIconSize(QSize(ICON_SIZE, ICON_SIZE))
        self.addNodeTB.setIcon(QtGui.QIcon(':/plugins/Qstream/icons/addNode.png'))
        #self.deleteNodeTB.setMinimumSize(QSize(192, ICON_SIZE))
        self.addNodeTB.setIconSize(QSize(ICON_SIZE, ICON_SIZE))

        ## General
        self.editGeneralTB.setIcon(QtGui.QIcon(':/plugins/Qstream/icons/general.png'))
        self.editGeneralTB.setIconSize(QSize(ICON_SIZE, ICON_SIZE))

        ## Simulation
        self.simulation_TB.setIcon(QtGui.QIcon(':/plugins/Qstream/icons/simulation.png'))
        self.simulation_TB.setIconSize(QSize(ICON_SIZE, ICON_SIZE))

        # Demand panel
        self.demandTemplateTB.setIcon(QtGui.QIcon(':/plugins/Qstream/icons/createODmatrix.png'))
        self.demandTemplateTB.setIconSize(QSize(ICON_SIZE,ICON_SIZE))
        self.demandImportTB.setIcon(QtGui.QIcon(':/plugins/Qstream/icons/importODmatrix.png'))
        self.demandImportTB.setIconSize(QSize(ICON_SIZE,ICON_SIZE))

        #...
        # CONNECT BUTTONS TO FUNCTIONS  !
        #..
        # documentation
        self.openDoc_TB.clicked.connect(self.openDocumentation)
        #...
        # Network tab
        self.newTB.clicked.connect(self.newScenario)
        self.importTB.clicked.connect(self.loadScenario)
        self.saveTB.clicked.connect(self.stopEdition)
        self.exportTB.clicked.connect(self.exportCallback)
        self.addLinkTB.clicked.connect(self.addLink)
        self.addNodeTB.clicked.connect(self.generateNodes)
        self.reverseLinkTB.clicked.connect(self.reverseSelectedLinks)
        self.addLinkReverseTB.clicked.connect(self.addLinkReverse)
        self.mergeNodeTB.clicked.connect(self.mergeNodes)
        self.splitNodeTB.clicked.connect(self.splitNode)
        self.editGeneralTB.clicked.connect(self.editGeneralcallback)
        self.openFolder_TB.clicked.connect(self.openFolder)
        #self.execute_TB.clicked.connect(self.execute_script)

        #...
        # demand panel
        self.demandTemplateTB.clicked.connect(self.generateEmptyDemand)
        self.demandImportTB.clicked.connect(self.importDemand)
        # TODO:
        self.roadType_TB.clicked.connect(self.editRoadTypesCallback)

        #...
        #Regulation tab
        self.addRegul_TB.clicked.connect(partial(self.addExtension, "Regulations"))
        self.addML_TB.clicked.connect(self.addMLcallback)
        self.editRegul_TB.clicked.connect(self.editRegulationCallback)
        self.delRegul_TB.clicked.connect(self.deleteRegulationCallback)

        #...
        #Simulation tab
        self.simulation_TB.clicked.connect(self.simulationCallback)

        #...
        # Analysis tab
        self.displayNetwork_PB.clicked.connect(self.displayNetwork)
        self.speedFlow_PB.clicked.connect(self.displaySpeedFlowOnLinks)
        self.linkTT_PB.clicked.connect(self.TTlinks)
        self.pathTT_PB.clicked.connect(self.TTPath)
        self.nodeAn_PB.clicked.connect(self.nodeAnalysis)
        self.generateXT_PB.clicked.connect(self.generateXT)
        self.XTDiag_PB.clicked.connect(self.diagXT)
        self.traficolor_PB.clicked.connect(self.traficolor)

        #...
        # Export csv
        self.csv_SF_PB.clicked.connect(self.exportSFCallback)
        self.csv_TT_PB.clicked.connect(self.exportTTCallback)

        #...
        # Devs
        self.deleteNodesTB.clicked.connect(self.deleteAllNodes)

        # initialization
        try:
            layer = QgsProject.instance().mapLayersByName("General")[0]
            self.currentGpkg = layer.dataProvider().dataSourceUri().split('|layername=')[0]
            self.updateRegulationsDisplay()
        except:
            """ do nothing """

    def closeEvent(self, event):
        self.closingPlugin.emit()
        event.accept()

    """  Cleaning all layers  """
    def cleanAllLayers(self):
        mc = iface.mapCanvas()
        layers = []
        layers.extend(QgsProject.instance().mapLayersByName("Feux"))
        layers.extend(QgsProject.instance().mapLayersByName("Centroides"))
        layers.extend(QgsProject.instance().mapLayersByName("Noeuds"))
        layers.extend(QgsProject.instance().mapLayersByName("Demand"))
        layers.extend(QgsProject.instance().mapLayersByName("Liens"))
        layers.extend(QgsProject.instance().mapLayersByName("VehicleTypes"))
        layers.extend(QgsProject.instance().mapLayersByName("RoadTypes"))
        layers.extend(QgsProject.instance().mapLayersByName("Periods"))
        layers.extend(QgsProject.instance().mapLayersByName("General"))
        layers.extend(QgsProject.instance().mapLayersByName("Regulations"))

        QgsProject.instance().removeMapLayers([layer.id() for layer in layers])
        mc.refresh()

    """  Applay the basic style for all the layers  """
    def applyBasicStyle(self):
        layer = QgsProject.instance().mapLayersByName("Noeuds")[0]
        layer.loadNamedStyle(absolutePath("baseQstream/StyleDesNoeuds.qml"))

        layer = QgsProject.instance().mapLayersByName("Liens")[0]
        layer.loadNamedStyle(absolutePath("baseQstream/StyleDesLiens.qml"))

        layer = QgsProject.instance().mapLayersByName("Feux")[0]
        layer.loadNamedStyle(absolutePath("baseQstream/StyleDesFeux.qml"))

    def getCurrentFolder(self):
        return os.path.dirname(self.currentGpkg)

    def openFolder(self):
        folder = self.getCurrentFolder()
        import pathlib
        windowsFolder = pathlib.PureWindowsPath(folder)
        correct_folder = pathlib.Path(windowsFolder)
        os.system('start ' + str(correct_folder))

    def newScenario(self):
        ###### Get path to file
        gpkgPath , _ = QtWidgets.QFileDialog.getSaveFileName(self, "Save new GeoPackage as", "", "GeoPackage (*.gpkg)")
        if gpkgPath == '':
            return
        self.workingFolder = os.path.dirname(gpkgPath)
        self.currentGpkg = gpkgPath

        # ######FILE MANAGEMENT
        old_name = absolutePath('baseQstream/base.gpkg')
        shutil.copy(old_name, gpkgPath)

        # clean layers
        self.cleanAllLayers()

        ####### Open the layers and add them to the workspace
        uri = absolutePath(gpkgPath +"|layername=demand")
        layer = iface.addVectorLayer(uri, "Demand", "ogr")

        uri = absolutePath(gpkgPath +"|layername=VehicleTypes")
        layer = iface.addVectorLayer(uri, "VehicleTypes", "ogr")

        uri = absolutePath(gpkgPath +"|layername=RoadTypes")
        layer = iface.addVectorLayer(uri, "RoadTypes", "ogr")

        uri = absolutePath(gpkgPath +"|layername=Periods")
        layer = iface.addVectorLayer(uri, "Periods", "ogr")

        uri = absolutePath(gpkgPath +"|layername=Noeuds")
        layer = iface.addVectorLayer(uri, "Noeuds", "ogr")

        uri = absolutePath(gpkgPath +"|layername=Liens")
        layer = iface.addVectorLayer(uri, "Liens", "ogr")

        uri = absolutePath(gpkgPath +"|layername=Feux")
        layer = iface.addVectorLayer(uri, "Feux", "ogr")

        uri = absolutePath(gpkgPath +"|layername=General")
        layer = iface.addVectorLayer(uri, "General", "ogr")

        ####### Apply basic style
        self.applyBasicStyle()

    """ Load a scenario from a GeoPackage file """
    def loadScenario(self):
        """displays open file dialog to select bus track input file"""
        gpkgPath, _ = QtWidgets.QFileDialog.getOpenFileName(self, "Select Scenario GeoPackage", "", "GeoPackage (*.gpkg)")
        self.workingFolder = os.path.dirname(gpkgPath)
        self.currentGpkg = gpkgPath
        if gpkgPath:
            """ delete all layers in project"""
            self.cleanAllLayers()

            """ open the GeoPackage layers"""
            uri = absolutePath(gpkgPath +"|layername=demand")
            layer = iface.addVectorLayer(uri, "Demand", "ogr")

            uri = absolutePath(gpkgPath +"|layername=VehicleTypes")
            layer = iface.addVectorLayer(uri, "VehicleTypes", "ogr")

            uri = absolutePath(gpkgPath +"|layername=RoadTypes")
            layer = iface.addVectorLayer(uri, "RoadTypes", "ogr")

            uri = absolutePath(gpkgPath +"|layername=Periods")
            layer = iface.addVectorLayer(uri, "Periods", "ogr")

            uri = absolutePath(gpkgPath +"|layername=Noeuds")
            layer = iface.addVectorLayer(uri, "Noeuds", "ogr")

            uri = absolutePath(gpkgPath +"|layername=Liens")
            layer = iface.addVectorLayer(uri, "Liens", "ogr")

            uri = absolutePath(gpkgPath +"|layername=Feux")
            layer = iface.addVectorLayer(uri, "Feux", "ogr")

            uri = absolutePath(gpkgPath +"|layername=General")
            from qgis.core import QgsVectorLayer
            test = QgsVectorLayer(uri, "General", "ogr")
            if not test.isValid():
                layer = self.addMissingLayer("General")
            else:
                layer = iface.addVectorLayer(uri, "General", "ogr")

            uri = absolutePath(gpkgPath +"|layername=Regulations")
            from qgis.core import QgsVectorLayer
            test = QgsVectorLayer(uri, "Regulations", "ogr")
            if not test.isValid():
                print("No regulations layer for the moment, maybe you should add one...")
            else:
                layer = iface.addVectorLayer(uri, "Regulations", "ogr")
                self.updateRegulationsDisplay()

            self.applyBasicStyle()

    """ In case of incomplete file during loading """
    def addMissingLayer(self, name):
        #...
        basePath = absolutePath('baseQstream/base.gpkg')
        #...
        uri = absolutePath(basePath + "|layername=" + name)
        layer = QgsVectorLayer(uri, name, 'ogr')
        #...
        # save the new layer in the curr gpkg
        options = QgsVectorFileWriter.SaveVectorOptions()
        options.actionOnExistingFile = QgsVectorFileWriter.CreateOrOverwriteLayer
        options.layerName = layer.name()
        QgsVectorFileWriter.writeAsVectorFormat(layer, self.currentGpkg, options)
        #...
        uri = absolutePath(self.currentGpkg + "|layername=" + name)
        layer = iface.addVectorLayer(uri, name , "ogr")
        return layer

    """Add a layer to the gpkg on demand"""
    def addExtension(self, name):
        #...
        # Test if the layer already exists
        if not len(QgsProject.instance().mapLayersByName(name))==0:
            #...
            # Do nothing in case of existing layer
            return
        #...
        extensionPath = absolutePath('baseQstream/extensions.gpkg')
        #...
        uri = absolutePath(extensionPath + "|layername=" + name)
        layer = QgsVectorLayer(uri, name, 'ogr')
        #...
        # save the new layer in the curr gpkg
        options = QgsVectorFileWriter.SaveVectorOptions()
        options.actionOnExistingFile = QgsVectorFileWriter.CreateOrOverwriteLayer
        options.layerName = layer.name()
        QgsVectorFileWriter.writeAsVectorFormat(layer, self.currentGpkg, options)
        #...
        uri = absolutePath(self.currentGpkg + "|layername=" + name)
        layer = iface.addVectorLayer(uri, name , "ogr")
        return layer

    def stopEdition(self):
        mc = iface.mapCanvas()
        # Asking to commit all changes
        save_msg = "Voulez vous enregistrer les modifcations dans la base (iréversible) ?"
        reply = QtWidgets.QMessageBox.question(self, 'Message',
                         save_msg, QtWidgets.QMessageBox.Yes, QtWidgets.QMessageBox.No)
        if reply == QtWidgets.QMessageBox.Yes:
            for layer in mc.layers():
                if layer.isEditable():
                    layer.commitChanges()
            return
        else:
            return

    def addLink(self):
        layer = QgsProject.instance().mapLayersByName("Liens")[0]
        iface.setActiveLayer(layer)
        layer.startEditing()
        iface.actionAddFeature().trigger()

    # Generate the nodes
    def generateNodes(self):
        # commit all
        self.stopEdition()
        #Loop over the links """
        try:
            linkLayer = QgsProject.instance().mapLayersByName("Liens")[0]
            nodeLayer = QgsProject.instance().mapLayersByName("Noeuds")[0]
        except IndexError:
            print("No link layer...")
            return
        # Delete all nodes
        with edit(nodeLayer):
                    listOfIds = [feat.id() for feat in nodeLayer.getFeatures()]
                    nodeLayer.deleteFeatures( listOfIds )
        # Loop on all the feratures to store the first points
        features = linkLayer.getFeatures()
        coords = np.zeros([2*linkLayer.featureCount() , 4])
        i = 0
        for feature in features:
            coords[i,0] = feature.id()
            coords[i,1] = 0
            geom = feature.geometry()
            geomSingleType = QgsWkbTypes.isSingleType(geom.wkbType())
            if geom.type()==QgsWkbTypes.LineGeometry:
                if geomSingleType:
                    x = geom.asPolyline()
                    coords[i,2] = x[0][0]
                    coords[i,3] = x[0][1]
                else:
                    x = geom.asMultiPolyline()
                    coords[i,2] = x[0][0][0]
                    coords[i,3] = x[0][0][1]
            i+=1
        # Loop on all the features tp store the last points
        features = linkLayer.getFeatures()
        for feature in features:
            coords[i,0] = feature.id()
            coords[i,1] = 2
            geom = feature.geometry()
            geomSingleType = QgsWkbTypes.isSingleType(geom.wkbType())
            if geom.type()==QgsWkbTypes.LineGeometry:
                if geomSingleType:
                    x = geom.asPolyline()
                    coords[i,2] = x[-1][0]
                    coords[i,3] = x[-1][1]
                else:
                    x = geom.asMultiPolyline()
                    coords[i,2] = x[0][-1][0]
                    coords[i,3] = x[0][-1][1]
            i+=1
        # Get the uniques coords to ensure that the nodes are not duplicated
        uniques = np.unique(coords[:,2:4], axis=0)
        # Generate the nodes
        with edit(nodeLayer):
            for i in range(len(uniques)):
                feat = QgsFeature(nodeLayer.fields())
                feat['fid'] = i+1
                feat.setGeometry(QgsGeometry.fromPointXY(QgsPointXY(uniques[i,0], uniques[i,1])))
                (res, outFeats) = nodeLayer.dataProvider().addFeatures([feat])

        # Assign the nodes to the links
        features = nodeLayer.getFeatures()
        with edit(linkLayer):
            # Loop over the nodes
            count = 0
            for feature in features:
                X = feature.geometry().asPoint()[0]
                Y = feature.geometry().asPoint()[1]
                # get the lines in coords where the node appear
                lines = np.unique(np.where(coords[:,2:4]==[X,Y])[0])
                # get fids
                fidsAndPlaces = coords[lines, 0:2]
                fidsAndPlaces = fidsAndPlaces[fidsAndPlaces[:,0].argsort()]
                fids = list(fidsAndPlaces[:,0])
                # get places 0 = upstram / 2 = downstream
                places = list(fidsAndPlaces[:,1])
                # get Features corresponding to the fids
                linkFeats = linkLayer.getFeatures(QgsFeatureRequest().setFilterFids(fids))
                i = 0
                # Loop over the features
                for feat in linkFeats:
                    # if it is an upstream node
                    if places[i] == 0.:
                        linkLayer.dataProvider().changeAttributeValues({feat.id() : {3 : feature.id()}})
                    # if it is a downstream node
                    elif places[i] == 2.:
                        linkLayer.dataProvider().changeAttributeValues({feat.id() : {4 : feature.id()}})
                    else:
                        print('ERROR HERE / Search for E-001')
                    i += 1
        # Assign types
        with edit(nodeLayer):
            nodes = nodeLayer.getFeatures()
            for node in nodes:
                # Test if links has this node as upstream node
                expr = QgsExpression( "\"up_node\"='{}'".format( node.id() ) )
                features = linkLayer.getFeatures( QgsFeatureRequest( expr ) )
                # if it is empty
                if not features.nextFeature(QgsFeature()):
                    nodeLayer.dataProvider().changeAttributeValues({node.id() : {1 : 2}})
                    continue
                # Test if links has this node as downstream node
                expr = QgsExpression( "\"down_node\"='{}'".format( node.id() ) )
                features = linkLayer.getFeatures( QgsFeatureRequest( expr ) )
                # if it is empty
                if not features.nextFeature(QgsFeature()):
                    nodeLayer.dataProvider().changeAttributeValues({node.id() : {1 : 1}})
                    continue
                nodeLayer.dataProvider().changeAttributeValues({node.id() : {1 : 0}})


    # Reverse the selected link
    def reverseSelectedLinks(self):
        try:
            layer = QgsProject.instance().mapLayersByName("Liens")[0]
        except IndexError:
            print("No link layer...")
            return

        with edit(layer):
            features = layer.selectedFeatures()
            for feature in features:
                geom = feature.geometry()
                geomSingleType = QgsWkbTypes.isSingleType(geom.wkbType())
                if geom.type()==QgsWkbTypes.LineGeometry:
                    if geomSingleType:
                        #TODO
                        print("Dev Notes : maybe useless here but if you see it in the console, this case has to be handled")
                    else:
                        x = geom.asMultiPolyline()
                        x[0].reverse()
                        newgeom = QgsGeometry.fromMultiPolylineXY(x)
                        layer.changeGeometry(feature.id(),newgeom)

    def addLinkReverse(self):
        offset = 5
        #Loop over the links """
        try:
            layer = QgsProject.instance().mapLayersByName("Liens")[0]
        except IndexError:
            print("No link layer...")

        with edit(layer):
            features = layer.selectedFeatures()
            for feature in features:
                print("Feature ID: ", feature.id())
                geom = feature.geometry()
                geomSingleType = QgsWkbTypes.isSingleType(geom.wkbType())
                if geom.type()==QgsWkbTypes.LineGeometry:
                    if geomSingleType:
                        print("Dev Notes : maybe useless here but if you see it in the console, this case has to be handled")

                    else:
                        x = geom.asMultiPolyline()
                        newPoints = []
                        # first point
                        X = x[0][0][0] + offset*(x[0][0][1]-x[0][1][1])/((x[0][1][0]-x[0][0][0])**2 + (x[0][1][1]-x[0][0][1])**2)**0.5
                        Y = x[0][0][1] + offset*(x[0][1][0]-x[0][0][0])/((x[0][1][0]-x[0][0][0])**2 + (x[0][1][1]-x[0][0][1])**2)**0.5
                        newPoints.append(QgsPointXY(X,Y))
                        #last point
                        N = len(x[0]) - 1
                        for i in range(1,N):
                            x1 = x[0][i][0] + offset*(x[0][i-1][1]-x[0][i][1])/((x[0][i][0]-x[0][i-1][0])**2 + (x[0][i][1]-x[0][i-1][1])**2)**0.5
                            y1 = x[0][i][1] + offset*(x[0][i][0]-x[0][i-1][0])/((x[0][i][0]-x[0][i-1][0])**2 + (x[0][i][1]-x[0][i-1][1])**2)**0.5
                            x2 = x[0][i][0] + offset*(x[0][i][1]-x[0][i+1][1])/((x[0][i+1][0]-x[0][i][0])**2 + (x[0][i+1][1]-x[0][i][1])**2)**0.5
                            y2 = x[0][i][1] + offset*(x[0][i+1][0]-x[0][i][0])/((x[0][i+1][0]-x[0][i][0])**2 + (x[0][i+1][1]-x[0][i][1])**2)**0.5
                            X = (x1 + x2)/2
                            Y = (y1 + y2)/2
                            # TODO !! Faire quand Etienne sera parti
                            newPoints.append(QgsPointXY(X,Y))
                        #last point
                        X = x[0][N][0] + offset*(x[0][N-1][1]-x[0][N][1])/((x[0][N][0]-x[0][N-1][0])**2 + (x[0][N][1]-x[0][N-1][1])**2)**0.5
                        Y = x[0][N][1] + offset*(x[0][N][0]-x[0][N-1][0])/((x[0][N][0]-x[0][N-1][0])**2 + (x[0][N][1]-x[0][N-1][1])**2)**0.5
                        newPoints.append(QgsPointXY(X,Y))
                        # reverse
                        newPoints.reverse()
                        newgeom = QgsGeometry.fromMultiPolylineXY([newPoints])
                        feat = QgsFeature(layer.fields())
                        feat.setGeometry(newgeom)
                        (res, outFeats) = layer.dataProvider().addFeatures([feat])

    def mergeNodes(self):
        #Loop over the links """
        try:
            nodesLayer = QgsProject.instance().mapLayersByName("Noeuds")[0]
            linksLayer = QgsProject.instance().mapLayersByName("Liens")[0]
        except IndexError:
            print("No link layer...")

        with edit(nodesLayer):
            features = nodesLayer.selectedFeatures()
            if features:
                n = 0
                xData = []
                yData = []
                delIDs = []
                for feature in features:
                    n += 1
                    geom = feature.geometry().asPoint()
                    delIDs.append(feature.id())
                    xData.append(geom[0])
                    yData.append(geom[1])
                xBar = sum(xData)/n
                yBar = sum(yData)/n
                newGeom = QgsGeometry.fromPointXY(QgsPointXY(xBar,yBar))
                newFeat = QgsFeature(nodesLayer.fields())
                newFeat["type"] = 0
                newFeat.setGeometry(newGeom)
                (res, outFeats) = nodesLayer.dataProvider().addFeatures([newFeat])
                newID = outFeats[0].id()
                nodesLayer.deleteFeatures(delIDs)

        # Modification of the links layer
        with edit(linksLayer):
            # Loop over all the IDS of the deleted nodes
            for id in delIDs:
                # Catch the links that have this node in UpNode
                expr = QgsExpression( "\"up_node\"='{}'".format( id ) )
                features = linksLayer.getFeatures( QgsFeatureRequest( expr ) )
                # Loop over the links selected
                for feature in features:
                    # modify the up_node to the newID
                    linksLayer.dataProvider().changeAttributeValues({feature.id() : {4 : newID}})
                # Catch the links that haver this node in DownNode
                expr = QgsExpression( "\"down_node\"='{}'".format( id ) )
                features = linksLayer.getFeatures( QgsFeatureRequest( expr ) )
                # Loop over the links selected
                for feature in features:
                    # modify the down_node to the newID
                    linksLayer.dataProvider().changeAttributeValues({feature.id() : {5 : newID}})

    def splitNode(self):
        #Loop over the links """
        try:
            nodesLayer = QgsProject.instance().mapLayersByName("Noeuds")[0]
            linksLayer = QgsProject.instance().mapLayersByName("Liens")[0]
        except IndexError:
            print("No link layer...")

        # Deleting the nodes
        with edit(nodesLayer):
            features = nodesLayer.selectedFeatures()
            if features:
                delIDs = []
                for feature in features:
                    delIDs.append(feature.id())
                # delete the features
                nodesLayer.deleteFeatures(delIDs)

        # Adding the new nodes
        with edit(nodesLayer):
            data = []
            for nodeID in delIDs:
                # Catch the links with that node in up_node
                expr = QgsExpression( "\"up_node\"='{}'".format( nodeID ) )
                features = linksLayer.getFeatures( QgsFeatureRequest( expr ) )
                for feature in features:
                    point = feature.geometry().asMultiPolyline()[0][0]
                    newFeat = QgsFeature(nodesLayer.fields())
                    newFeat.setGeometry(QgsGeometry.fromPointXY(point))
                    newFeat["type"] = 1
                    (res, outFeat) = nodesLayer.dataProvider().addFeatures([newFeat])
                    data.append([feature.id(), outFeat[0].id(), 1])
                # Catch the links with that node in up_node
                expr = QgsExpression( "\"down_node\"='{}'".format( nodeID ) )
                features = linksLayer.getFeatures( QgsFeatureRequest( expr ) )
                for feature in features:
                    point = feature.geometry().asMultiPolyline()[0][-1]
                    newFeat = QgsFeature(nodesLayer.fields())
                    newFeat.setGeometry(QgsGeometry.fromPointXY(point))
                    newFeat["type"] = 2
                    (res, outFeat) = nodesLayer.dataProvider().addFeatures([newFeat])
                    data.append([feature.id(), outFeat[0].id(), 2])

        # Assigning the new nodes to the corresponding links
        with edit(linksLayer):
            for line in data:
                if line[2] == 1:
                    linksLayer.dataProvider().changeAttributeValues({line[0]:{4 : line[1]}})
                else:
                    linksLayer.dataProvider().changeAttributeValues({line[0]:{5 : line[1]}})


    def generateEmptyDemand(self):
        # get layers
        try:
            nodeLayer = QgsProject.instance().mapLayersByName("Noeuds")[0]
            vTypeLayer =  QgsProject.instance().mapLayersByName("VehicleTypes")[0]
            periodsLayer = QgsProject.instance().mapLayersByName("Periods")[0]
            generalLayer = QgsProject.instance().mapLayersByName("General")[0]
        except IndexError:
            print("No layers")
            return

        # edit the period layer to take into account the generalLayer
        # Delete all periods
        with edit(periodsLayer):
                    listOfIds = [feat.id() for feat in periodsLayer.getFeatures()]
                    periodsLayer.deleteFeatures( listOfIds )

        with edit(periodsLayer):
            start = float(generalLayer.getFeature(1).attribute(2))
            end = float(generalLayer.getFeature(2).attribute(2))
            period = float(generalLayer.getFeature(3).attribute(2))
            count = 1
            newFeats = []
            currTime = start
            while currTime < end:
                newFeat = QgsFeature(periodsLayer.fields())
                newFeat["fid"] = count
                newFeat["start"] = start + period*(count-1)
                newFeats.append(newFeat)
                currTime += period
                count += 1
            periodsLayer.dataProvider().addFeatures(newFeats)

        folder = os.path.dirname( unicode( nodeLayer.dataProvider().dataSourceUri() ) )
        #TODO
        periodFeats = [feat for feat in periodsLayer.getFeatures()]
        if len(periodFeats)==0:
            #TODO 6h to 11h with 30min duration
            start = 0
            period = 15*60
            nb_periods = 4
        elif len(periodFeats)==1:
            # TODO: start at start during 1h with 30 minutes
            start = periodFeats[0]['start']
            period = 15*60
            nb_periods = 4
        else:
            start = periodFeats[0]['start']
            period = periodFeats[1]['start'] - start
            nb_periods = len(periodFeats)

        template = []
        data = {}

        # Destination
        firstLine = ['']
        N = 0
        expr = QgsExpression( "\"type\"='{}'".format( 2 ) )
        nodes = nodeLayer.getFeatures( QgsFeatureRequest( expr ) )
        for node in nodes:
            N+=1
            if node['name']:
                firstLine.append(node['name'])
            else:
                firstLine.append('fid_' + str(node.id()))
        template.append(firstLine)

        # Origins
        expr = QgsExpression( "\"type\"='{}'".format( 1 ) )
        nodes = nodeLayer.getFeatures( QgsFeatureRequest( expr ) )
        for node in nodes:
            if node['name']:
                line = [node['name']]
            else:
                line = ['fid_' + str(node.id())]
            line.extend(N*[0.0])
            template.append(line)

        # Write
        vtypes = vTypeLayer.getFeatures()
        for vtype in vtypes:
            for j in range(nb_periods):
                data.update({vtype['name'] + ' ' + convertSecondsTohhmmss(start+j*period) : template})

        save_data(os.path.join(folder,'OD_matrix.ods'),data)

    ## Import demand
    def importDemand(self):
        try:
            periodsLayer = QgsProject.instance().mapLayersByName("Periods")[0]
            demandLayer = QgsProject.instance().mapLayersByName("Demand")[0]
            vTypesLayer = QgsProject.instance().mapLayersByName("VehicleTypes")[0]
            nodesLayer = QgsProject.instance().mapLayersByName("Noeuds")[0]
        except IndexError:
            print("No Layers")

        """displays open file dialog to select bus track input file"""
        file, _ = QtWidgets.QFileDialog.getOpenFileName(self, "Select Demand ODS File", self.getCurrentFolder(), "GeoPackage (*.ods)")
        data = json.loads(json.dumps(get_data(file)))

        # delete everything in periods and Demand
        with edit(periodsLayer):
                # delete all periods features
                listOfIds = [feat.id() for feat in periodsLayer.getFeatures()]
                periodsLayer.deleteFeatures( listOfIds )
        with edit(demandLayer):
                # delete all periods features
                listOfIds = [feat.id() for feat in demandLayer.getFeatures()]
                demandLayer.deleteFeatures( listOfIds )

        # Sheets
        vehicleTypes = []
        periodsString = []
        for key in list(data.keys()):
            if not key.split(' ')[0] in vehicleTypes:
                vehicleTypes.append(key.split(' ')[0])
            if not key.split(' ')[1] in periodsString:
                periodsString.append(key.split(' ')[1])
        with edit(periodsLayer):
            for i in range(len(periodsString)):
                feat = QgsFeature(periodsLayer.fields())
                feat['fid'] = i+1
                feat['start'] = convertHHMMSStoSeconds(periodsString[i])
                (res, outFeats) = periodsLayer.dataProvider().addFeatures([feat])

        with edit(demandLayer):
            feat = QgsFeature()
            newFeats = []
            for sheet in data:
                lines = data[sheet]
                # Get vehicle type id
                expr = QgsExpression( "\"name\"='{}'".format( sheet.split(' ')[0] ) )
                vTypesLayer.getFeatures( QgsFeatureRequest( expr ) ).nextFeature(feat)
                vTypeID = feat.id()
                # Get period id
                expr = QgsExpression( "\"start\"='{}'".format(convertHHMMSStoSeconds(sheet.split(' ')[1] ) ))
                periodsLayer.getFeatures( QgsFeatureRequest( expr ) ).nextFeature(feat)
                periodID = feat.id()
                ##### ADVANCEMENT
                total = len(vehicleTypes)*len(periodsString)*(len(lines)-1)*(len(lines[0])-1)
                # for each cell
                for i in range(1,len(lines)):
                    for j in range(1,len(lines[0])):
                        # lines[i][j] is the value of flow from origin lines[i][0]
                        # to destination lines[0][j]
                        # Get origin feature id
                        nodeNameCalc = lines[i][0]
                        if nodesLayer.getFeatures(QgsFeatureRequest(QgsExpression("\"name\"='{}'".format(nodeNameCalc)))).nextFeature(feat):
                            originID = feat.id()
                        else:
                            originID = int(nodeNameCalc.split('_')[1])
                        # Get destination feature id
                        nodeNameCalc = lines[0][j]
                        if nodesLayer.getFeatures(QgsFeatureRequest(QgsExpression("\"name\"='{}'".format(nodeNameCalc)))).nextFeature(feat):
                            destinationID = feat.id()
                        else:
                            destinationID = int(nodeNameCalc.split('_')[1])
                        # Create new feature of demands
                        newFeat = QgsFeature(demandLayer.fields())
                        newFeat['origin'] = originID
                        newFeat['destination'] = destinationID
                        newFeat['vehicle_type'] = vTypeID
                        newFeat['period'] = periodID
                        newFeat['flow'] = lines[i][j]
                        newFeats.append(newFeat)
            (res, outFeats) = demandLayer.dataProvider().addFeatures(newFeats)

    def addMLcallback(self):
        """ function that add a managed lane """
        try:
            layer = QgsProject.instance().mapLayersByName("Regulations")[0]
            linkLayer = QgsProject.instance().mapLayersByName("Liens")[0]
            typeLayer = QgsProject.instance().mapLayersByName("VehicleTypes")[0]
        except IndexError:
            print("No regulation Layer")
            return
        # get selected...
        selectedFids = [str(feat.id()) for feat in linkLayer.selectedFeatures()]
        #...
        # display the dialog to add managed lane
        args = self.getEditManagedLaneData(selectedFids)
        if len(args)!=0:
            #...
            with edit(layer):
                try:
                    maxFid = max([feat.id() for feat in layer.getFeatures()])
                except:
                    maxFid = 0
                newFeat = QgsFeature(layer.fields())
                newFeat['fid'] = maxFid + 1
                newFeat['Type'] = 'managed_lane'
                newFeat['Arguments'] = args
                layer.dataProvider().addFeatures([newFeat])
            self.updateRegulationsDisplay()
        return

    def editGeneralcallback(self):
        """ function that edit the General variable """
        try:
            layer = QgsProject.instance().mapLayersByName("General")[0]
        except IndexError:
            print("No General Layer")
        #...
        values = {1 : '', 2 : '', 3 : '', 4 : False, 5 : ''}
        for feat in layer.getFeatures():
            values[feat.id()] = feat['value']
        #...
        General = self.getEditGeneralData(values)
        if len(General)!=0:
            #...
            with edit(layer):
                featsToDelete = [feat.id() for feat in layer.getFeatures()]
                layer.dataProvider().deleteFeatures(featsToDelete)
                # init new feats
                newFeats = []
                # Create new feature for start
                newFeat = QgsFeature(layer.fields())
                newFeat['fid'] = 1
                newFeat['name'] = 'SimulationStart'
                newFeat['value'] = General['SimulationStart']
                newFeats.append(newFeat)
                # end
                newFeat = QgsFeature(layer.fields())
                newFeat['fid'] = 2
                newFeat['name'] = 'SimulationEnd'
                newFeat['value'] = General['SimulationEnd']
                newFeats.append(newFeat)
                # step
                newFeat = QgsFeature(layer.fields())
                newFeat['fid'] = 3
                newFeat['name'] = 'TimeStep'
                newFeat['value'] = General['TimeStep']
                newFeats.append(newFeat)
                # Active upstream capa
                newFeat = QgsFeature(layer.fields())
                newFeat['fid'] = 4
                newFeat['name'] = 'ActiveUpStreamCapacity'
                newFeat['value'] = int(General['ActiveUpstreamCapacity'])
                newFeats.append(newFeat)
                # Active upstream capa
                newFeat = QgsFeature(layer.fields())
                newFeat['fid'] = 5
                newFeat['name'] = 'StreamDirectory'
                newFeat['value'] = General['StreamDirectory']
                newFeats.append(newFeat)
                # add the new feats to the layer
                (res, outFeats) = layer.dataProvider().addFeatures(newFeats)

        return

    def editRegulationCallback(self):
        try:
            layer = QgsProject.instance().mapLayersByName("Regulations")[0]
        except IndexError:
            print("No Regulations Layer")
            return
        selectedItems = self.regul_LW.selectedItems()
        if len(selectedItems)!=0:
            lineText = selectedItems[0].text()
        else:
            return
        feat = QgsFeature()
        layer.getFeatures(QgsFeatureRequest(QgsExpression("\"fid\"='{}'".format(str(lineText.split(' - ')[0]))))).nextFeature(feat)
        if feat['Type'] == 'managed_lane':
            previousInfos = json.loads(feat['Arguments'])
            newInfos = self.getEditManagedLaneData([], previousInfos=previousInfos)
            if len(newInfos)!=0:
                with edit(layer):
                    layer.changeAttributeValue(feat.id(), 2, newInfos)
        else:
            return

    def editRoadTypesCallback(self):
        try:
            layer = QgsProject.instance().mapLayersByName("RoadTypes")[0]
        except IndexError:
            print("No RoadTypes layer")
            return

        rtdict = {}
        for feat in layer.getFeatures():
            rtdict.update({feat.id() : {
                                        'name' : feat['name'],
                                        'u' : int(feat['speed']),
                                        'kx' : int(feat['jam_density']),
                                        'C' : int(feat['capacity'])
            }})
        newInfos = self.getEditRoadTypes(rtdict = rtdict)
        if len(newInfos)!=0:
            with edit(layer):
                # delete the features
                featsToDelete = [feat.id() for feat in layer.getFeatures()]
                layer.dataProvider().deleteFeatures(featsToDelete)
                # create the features
                newFeats = []
                for ID in list(newInfos.keys()):
                    newFeat = QgsFeature(layer.fields())
                    newFeat['fid'] = ID
                    newFeat['name'] = newInfos[ID]['name']
                    newFeat['speed'] = float(newInfos[ID]['u'])
                    newFeat['capacity'] = float(newInfos[ID]['C'])
                    newFeat['jam_density'] = float(newInfos[ID]['kx'])
                    newFeats.append(newFeat)
                layer.dataProvider().addFeatures(newFeats)

    def deleteRegulationCallback(self):
        try:
            layer = QgsProject.instance().mapLayersByName("Regulations")[0]
        except IndexError:
            print("No Regulations Layer")
            return

        selectedItems = self.regul_LW.selectedItems()
        if len(selectedItems)!=0:
            lineText = selectedItems[0].text()
        else:
            return
        feat = QgsFeature()
        layer.getFeatures(QgsFeatureRequest(QgsExpression("\"fid\"='{}'".format(str(lineText.split(' - ')[0]))))).nextFeature(feat)

        if feat:
            with edit(layer):
                layer.dataProvider().deleteFeatures([feat.id()])
        self.updateRegulationsDisplay()
        return

    def exportCallback(self):
        sce = Scenario(self.currentGpkg)
        filename = sce.saveAsNpy(self.currentGpkg.split('.gpkg')[0])
        return filename

    def simulationCallback(self):
        npyPath = self.exportCallback()
        try:
            layer = QgsProject.instance().mapLayersByName("General")[0]
        except IndexError:
            print("No General Layer")
        #...
        feat = QgsFeature()
        layer.getFeatures(QgsFeatureRequest(QgsExpression("\"fid\"='{}'".format(5)))).nextFeature(feat)
        streamFolder = feat['value']

        #...
        #check stream
        try:
            f = open(os.path.join(streamFolder, 'infos'))
        except FileNotFoundError:
            print('The folder of stream is not correct')
            return

        lines = f.readlines()
        infos = {}
        for line in lines:
            lineSplitted = line.split(' = ')
            infos[lineSplitted[0]] = lineSplitted[1]

        version_vect = [int(item) for item in infos['version'].split('.')]
        goodV = [int(item) for item in STREAM_MIN_VERSION.split('.')]
        vInt = sum([version_vect[i] * 100**(2-i) for i in range(3)])
        goodvInt = sum([goodV[i] * 100**(2-i) for i in range(3)])

        if vInt < goodvInt:
            message = 'La version de stream est trop ancienne, utilisez au minimum : ' + STREAM_MIN_VERSION
            print(message)
            return
        #...
        # launch stream
        command = os.path.join(os.path.dirname(os.path.dirname(executable)),'apps', 'Python37', 'python') + " " + os.path.join(streamFolder,'stream', 'main.py') + " " + npyPath
        process = subprocess.Popen(command, creationflags=subprocess.CREATE_NEW_CONSOLE)

        return

    def getStreamFolder(self):
        try:
            layer = QgsProject.instance().mapLayersByName("General")[0]
        except IndexError:
            print("No Geenral layer")
            return
        #...
        feat = QgsFeature()
        layer.getFeatures(QgsFeatureRequest(QgsExpression("\"fid\"='{}'".format(5)))).nextFeature(feat)
        streamFolder = feat['value']
        return streamFolder

    def updateRegulationsDisplay(self):
        try:
            layer = QgsProject.instance().mapLayersByName("Regulations")[0]
        except IndexError:
            print("No Regulations Layer")
            return
        #...
        # clear the content of the list
        self.regul_LW.clear()
        #...
        # add the regulations
        for feat in layer.getFeatures():
            self.regul_LW.addItem(str(feat.id()) + " - " + correspondance_noms_regul[feat["Type"]])
        self.update()

###############################################################################
    """ functions to get values from forms into the 'forms' folder """
    def getEditManagedLaneData(self, selectedFids, previousInfos = None):
        """ display a custom dialog to edit a regulation """
        try:
            linkLayer = QgsProject.instance().mapLayersByName("Liens")[0]
            typeLayer = QgsProject.instance().mapLayersByName("VehicleTypes")[0]
        except IndexError:
            print("No Regulations Layer")
            return
        #...
        # get the selected links and list of links
        linksFids = [feat.id() for feat in linkLayer.getFeatures()]
        # get the class dict
        classDict = {}
        for feat in typeLayer.getFeatures():
            classDict.update({feat.id() : feat['name']})

        res = ''
        dial = MLWidget(linksFids, selectedFids, classDict, previousInfos = previousInfos)
        dial.setAttribute(QtCore.Qt.WA_DeleteOnClose)
        if dial.exec_() == QtWidgets.QDialog.Accepted:
            res = dial.val
        return res

    def getEditGeneralData(self, values):
        """ display the custom dialog to edit the general variable """
        res = {}
        dial = GeneralWidget(values)
        dial.setAttribute(QtCore.Qt.WA_DeleteOnClose)
        if dial.exec_ () == QtWidgets.QDialog.Accepted:
            res = dial.val
        return res

    def getEditRoadTypes(self, rtdict):
        """ display the custom dialog to edit the road types """
        res = {}
        dial = RTWidget(rtdict)
        dial.setAttribute(QtCore.Qt.WA_DeleteOnClose)
        if dial.exec() == QtWidgets.QDialog.Accepted:
            res = dial.val
        return res

###############################################################################○
    """ Functions for analysis """
    def askForSimulation(self):
        file, _ = QtWidgets.QFileDialog.getOpenFileName(self, "Sélectionner un fichier de résultat", "", "Fichier Numpy (*.npy)")
        return file

    def askForXTinfos(self):
        file, _ = QtWidgets.QFileDialog.getOpenFileName(self, "Sélectionner un fichier d'infos XT", "", "Fichier Numpy (*.npy)")
        return file

    def displayNetwork(self):
        filePath = self.askForSimulation()
        if not self.getStreamFolder() in sys.path:
            sys.path.insert(0, self.getStreamFolder())
            print('Added stream folder to path')
        else:
            print('Stream path already added...')
        from stream.analysis.analysis import plot_network as pnet
        simulation = np.load(filePath).item(0)
        pnet(simulation)
        return

    def displaySpeedFlowOnLinks(self):
        """ plot travel times on selected links """
        try:
            linkLayer = QgsProject.instance().mapLayersByName("Liens")[0]
        except IndexError:
            print("No regulation Layer")
            return
        # get selected...
        selectedFids = [feat.id() for feat in linkLayer.selectedFeatures()]
        filePath = self.askForSimulation()
        #...
        if not self.getStreamFolder() in sys.path:
            sys.path.insert(0, self.getStreamFolder())
            print('Added stream folder to path')
        else:
            print('Stream path already added...')
        #...
        from stream.analysis.analysis import compute_travel_times_on_links, compute_stats_on_links, plot_flow_speed_on_link
        Simulation = np.load(filePath).item(0)
        TravelTimes = compute_travel_times_on_links( Simulation )
        Statistics = compute_stats_on_links( Simulation, TravelTimes )

        for fid in selectedFids:
            plot_flow_speed_on_link( Statistics, fid )
        return

    def TTlinks(self):
        """ plot travel times on selected links """
        try:
            linkLayer = QgsProject.instance().mapLayersByName("Liens")[0]
        except IndexError:
            print("No regulation Layer")
            return
        # get selected...
        selectedFids = [feat.id() for feat in linkLayer.selectedFeatures()]
        filePath = self.askForSimulation()
        #...
        if not self.getStreamFolder() in sys.path:
            sys.path.insert(0, self.getStreamFolder())
            print('Added stream folder to path')
        else:
            print('Stream path already added...')
        #...
        from stream.analysis.analysis import plot_travel_times_on_path as TTpath
        simulation = np.load(filePath).item(0)
        for fid in selectedFids:
            TTpath(simulation, [fid])
        return

    def TTPath(self):
        try:
            layer = QgsProject.instance().mapLayersByName("Noeuds")[0]
        except IndexError:
            print("No node Layer")
            return
        # get selected...
        selectedFids = [feat.id() for feat in layer.selectedFeatures()]
        filePath = self.askForSimulation()
        #...
        if not self.getStreamFolder() in sys.path:
            sys.path.insert(0, self.getStreamFolder())
            print('Added stream folder to path')
        else:
            print('Stream path already added...')
        #...
        from stream.analysis.analysis import plot_travel_times_on_path as TTpath
        import stream.initialization.routes as routes
        simulation = np.load(filePath).item(0)
        for nodeid in selectedFids:
            remainingIDs = [fid for fid in selectedFids]
            remainingIDs.remove(nodeid)
            for node2 in remainingIDs:
                path = routes.getLinkPath(routes.getPathByNodes(simulation, nodeid, node2), simulation)
                if len(path)!=0:
                    TTpath(simulation,path, bool_network = True)
        return

    def nodeAnalysis(self):
        try:
            layer = QgsProject.instance().mapLayersByName("Noeuds")[0]
        except IndexError:
            print("No node Layer")
            return
        # get selected...
        selectedFids = [feat.id() for feat in layer.selectedFeatures()]
        filePath = self.askForSimulation()
        #...
        if not self.getStreamFolder() in sys.path:
            sys.path.insert(0, self.getStreamFolder())
            print('Added stream folder to path')
        else:
            print('Stream path already added...')
        #...
        from stream.analysis.analysis import plot_node_analysis as NodeAn, node_info
        simulation = np.load(filePath).item(0)
        for nodeid in selectedFids:
            NodeEvent = node_info( simulation, nodeid )
            NodeAn(NodeEvent)

        return

    def generateXT(self):
        res = {}
        dial = generateXTWidget(self.getCurrentFolder())
        dial.setAttribute(QtCore.Qt.WA_DeleteOnClose)
        if dial.exec_() == QtWidgets.QDialog.Accepted:
            res = dial.val
        if len(res)==0:
            return
        file = res['file']
        name = res['name']
        dx = str(res['dx'])
        dt = str(res['dt'])
        if len(name)==0:
            name = 'XTinfos'

        try:
            layer = QgsProject.instance().mapLayersByName("General")[0]
        except IndexError:
            print("No General Layer")
        #...
        feat = QgsFeature()
        layer.getFeatures(QgsFeatureRequest(QgsExpression("\"fid\"='{}'".format(5)))).nextFeature(feat)
        streamFolder = feat['value']

        #...
        #check stream
        try:
            f = open(os.path.join(streamFolder, 'infos'))
        except FileNotFoundError:
            print('The folder of stream is not correct')

        lines = f.readlines()
        infos = {}
        for line in lines:
            lineSplitted = line.split(' = ')
            infos[lineSplitted[0]] = lineSplitted[1]

        version_vect = [int(item) for item in infos['version'].split('.')]
        goodV = [int(item) for item in STREAM_MIN_VERSION.split('.')]
        vInt = sum([version_vect[i] * 100**(2-i) for i in range(3)])
        goodvInt = sum([goodV[i] * 100**(2-i) for i in range(3)])

        if vInt < goodvInt:
            message = 'The stream version is too old, you need at least the version ' + STREAM_MIN_VERSION
            print(message)
            return
        #...
        # launch stream
        command = os.path.join(os.path.dirname(os.path.dirname(executable)),'apps', 'Python37', 'python') + " " + os.path.join(streamFolder,'stream', 'analysis','diagXT.py') + " " + file + " " + name + " " + dx + " " + dt
        process = subprocess.Popen(command, creationflags=subprocess.CREATE_NEW_CONSOLE)
        return

    def diagXT(self):
        filePath = self.askForXTinfos()
        try:
            linkLayer = QgsProject.instance().mapLayersByName("Liens")[0]
        except IndexError:
            print("No regulation Layer")
            return
        # get selected...
        selectedFids = [feat.id() for feat in linkLayer.selectedFeatures()]
        #...
        if not self.getStreamFolder() in sys.path:
            sys.path.insert(0, self.getStreamFolder())
            print('Added stream folder to path')
        else:
            print('Stream path already added...')
        #...
        from stream.analysis.XTplots import plotXTDiagOnLink as plotXT
        Xtinfos = np.load(filePath).item(0)
        for fid in selectedFids:
            plotXT(Xtinfos[fid], fid)
        return

    def traficolor(self):
        fileSimu = self.askForSimulation()
        fileXT = self.askForXTinfos()
        infos = {
        'fileSimu' : fileSimu,
        'fileXT' : fileXT
        }
        if not self.getStreamFolder() in sys.path:
            sys.path.insert(0, self.getStreamFolder())
            print('Added stream folder to path')
        else:
            print('Stream path already added...')
        #...
        from stream.analysis.traficolorWidget import TraficolorWidget
        dial = TraficolorWidget(infos)
        return

###############################################################################
    """ export csv..."""
    def exportSFCallback(self):
        filePath = self.askForSimulation()
        if not self.getStreamFolder() in sys.path:
            sys.path.insert(0, self.getStreamFolder())
            print('Added stream folder to path')
        else:
            print('Stream path already added...')
        #...
        from stream.analysis.export import export_flow_speed_on_links as exportSF
        exportSF(np.load(filePath).item(0), os.path.dirname(filePath))
        return

    def exportTTCallback(self):
        filePath = self.askForSimulation()
        if not self.getStreamFolder() in sys.path:
            sys.path.insert(0, self.getStreamFolder())
            print('Added stream folder to path')
        else:
            print('Stream path already added...')
        #...
        from stream.analysis.export import export_travel_times_on_links as exportTT
        exportTT(np.load(filePath).item(0), os.path.dirname(filePath))
        return

###############################################################################
    """ DEV FUNCTION !!!!! """
    # TODO here !!!!!
    def deleteAllNodes(self):
        # select the layer of nodes
        try:
            layer = QgsProject.instance().mapLayersByName("Noeuds")[0]
        except IndexError:
            print("No link layer...")
            return

        # check if the layer is in edit mode
        if layer.isEditable():
            self.stopEdition()

        with edit(layer):
            listOfIds = [feat.id() for feat in layer.getFeatures()]
            layer.deleteFeatures( listOfIds )

    def deleteAllLinks(self):
        # select the layer of nodes
        try:
            layer = QgsProject.instance().mapLayersByName("Liens")[0]
        except IndexError:
            print("No link layer...")
            return

        # check if the layer is in edit mode
        if layer.isEditable():
            self.stopEdition()

        with edit(layer):
            listOfIds = [feat.id() for feat in layer.getFeatures()]
            layer.deleteFeatures( listOfIds )

    def openDocumentation(self):
        absPath = absolutePath("doc/index.html")
        os.system('start ' + absPath)

    def run_command(self,command):
        popen = subprocess.Popen(command, creationflags=subprocess.CREATE_NEW_CONSOLE ,stdout=subprocess.PIPE)
        # lines_iterator = iter(popen.stdout.readline, b"")
        # while popen.poll() is None:
        #     for line in lines_iterator:
        #         nline = line.rstrip()
        #         print(nline.decode("latin"), end = "\r\n",flush =True) # yield line

    def execute_script(self):
        file, _ = QtWidgets.QFileDialog.getOpenFileName(self, "Sélectionner un script python", self.getCurrentFolder(), "Scripts Python (*.py)")
        command = os.path.join(os.path.dirname(os.path.dirname(executable)),'apps', 'Python37', 'python') + " " + file
        self.run_command(command)
        return
